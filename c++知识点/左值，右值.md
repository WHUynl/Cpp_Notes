左值和右值的概念：

左值：**能对表达式取地址、或具名对象/变量**。一般指表达式结束后依然存在的**持久对象**。

右值：**不能对表达式取地址，或匿名对象。**一般指表达式结束就不再存在的**临时对象**。

### 左值引用与右值引用

###### 基本概念

```

```

我们平时经常使用的引用就是左值引用，通过 & 获取左值引用。为了支持移动操作，新标准引入 **右值引用** (rvalue reference)。顾名思义，**右值引用就是将引用绑定到右值。可以通过 && 来获取右值引用。比如：**

```c++
int i = 42; 
int &&r = i * 2;  // 将 i * 2 的结果绑定到 r 上
```

要注意只能将右值绑定到右值引用上，并且左值引用不能绑定右值，以下几种用法都是错误的：

```c++
int i = 42;
int &&rr = i;     // 错误，i 是左值
int &r = i * 2;   // 错误，i * 2 是右值
```

**但是右值可以绑定到 const 的左值引用上：**

```c++
int i = 42;
const int &r = i * 2;  // 正确，可以将 const 引用绑定到右值上
```

3.14不是一个对象，故int& a = 3.14一定是非法的，但是在const的情况下，事情是不一样的，如下所示：

```c++
const int &ri = 3.14;
// 以上将一个双精度浮点数绑定到整型引用上，可以分解为如下两步
const int tmp = 3.14;   // 1.先将双精度浮点数变成一个整型常量
const int &ri = tmp;    // 让常量引用 ri 绑定到这个临时变量上
//同时也说明了为什么没有const是不行的，因为const int 不能给int&作别名 
```

这种情况下，ri 会被绑定到一个 **临时量** (temporary)对象上，**所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。** 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。

#### 什么情况下使用右值引用

要了解什么情况下使用右值引用，我们就要先了充分了解右值的特性。首先与左值不同，右值是非常短暂的，它要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于这样的特性我们可以总结：

- 所引用的对象将要被销毁
- 该对象没有其他用户

这就意味着，**使用右值引用的代码可以自由的接管被引用对象的资源。**

需要注意的是，**所有的变量都是左值**，我们不能将一个右值引用绑定到一个右值引用类型的变量上。比如：

```c++
int &&rr1 = 42;   // 正确：字面量是右值
int &&rr2 = rr1;  // 错误：rr1 是变量，虽然他是右值引用，但任然是左值
```

可以这样理解：变量 rr1 是持久的，它不会像字面值 42 那样转瞬即逝，所以它是左值。这就引出了下面两个主题：**移动、转发**

#### 标准库 move 函数

虽然不能将一个右值引用绑定到左值上，**但我们可以显式地将一个左值转换为对应的右值引用类型。**这就是 **move** 的作用，move 定义在头文件 utility 中。可以用如下方式使用 move（**注意，为了避免潜在的名字冲突，使用 move 时不应使用 using 声明**）：

```c++
int&& rr1 = 42;  // 虽然 rr1 是右值引用类型，但其任然是变量，所以还是左值
int&& rr2 = std::move(rr1);  // 使用 std::move() 而不是 move()
```

调用 move 就相当于告诉编译器：我们有一个左值，但现在要像右值一样处理这个左值，**并且调用 move 就意味着：除了对 rr1 赋值或销毁以外，我们将不再使用它。也就是说，对于 rr1，我们可以赋予它新值，也可以销毁它，但是不能再使用其值了。**

#### 移动构造函数和移动赋值运算符

##### 移动构造

有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。

和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被**”窃取**“掉。**在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。**

可以用一个程序直观的感受一下移动构造：

```c++
#include <cstring>
#include <iostream>

class MyString {
 private:
  char* string;

 public:
  MyString() : string(nullptr) {}

  MyString(const char* str) {
    // 这里采用深拷贝
    string = (char*)malloc(strlen(str) + 1);
    strcpy(string, str);
    std::cout << "I'm constructor of class MyString" << std::endl;
  }

  MyString(const MyString& mystr) {
    // 这里同样是深拷贝，mystr 任然持有它自己的资源
    string = (char*)malloc(strlen(mystr.string) + 1);  // 为 string 分配新的资源
    strcpy(string, mystr.string);
    std::cout << "I'm copy constructor of class MyString" << std::endl;
  }

  MyString(MyString&& mystr) noexcept : string(mystr.string) {
    // 注意！移动构造函数，这里 mystr 已经不再持有任何资源
    // mystr.string 所指向的资源已经被当前对象窃取
    // 这里切记要将被移动的资源的指针置为空，为了防止析构函数析构其已经被转移的资源(即我们新对象      得到的资源被销毁)
    mystr.string = nullptr;
    std::cout << "I'm move constructor of class MyString" << std::endl;
  }

  ~MyString() {
    std::cout << "I'm destructor of class MyString" << std::endl;
    if (string) {
      // 如果 string 指针还持有资源的话，就将其释放
      free(string);
      std::cout << "free string!" << std::endl;
    }
  }
};

int main(int argc, char* argv[]) {
  MyString s1("hello world");//构造函数
  MyString s2(s1);//拷贝构造函数
   /*
   然而有些时候，我们不需要原来的对象了，比如我们用 s1 初始化 s2 之后，s1 将不再被需要了，这时    候我们进行深拷贝就非常的浪费时间浪费内存了，我们可以直接将 s1 的资源交给 s2 就行了，这时，移    动构造就派上用场了。
   */
  MyString s3(std::move(s1))//移动拷贝构造函数
  std::cout << std::endl;
  return 0;
```

##### 移动赋值

移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：

```c++
MyString& Mystring::operator=(MyString&& rhs) noexcept {
  if (this != &rhs) {
    if (string) free(string);  // 先将原有资源释放
    string = rhs.string;
    rhs.string = nullptr;
  }
  return *this;
}
```

### 注意事项

#### 异常保障

**由于移动操作只是”窃取”资源，不分配任何资源，所以通常不会抛出异常，当编写一个不抛出异常的移动操作时，我们应该通知使用者，**否则为了处理异常可能需要做一些额外的工作（比如标准库中的 vector，在发生异常后，需要将已经改变的部分复原，如：新分配的内存需要还回去，新插入的值需要删掉）。**可以用 noexcept 来指明函数不会抛出异常。(析构函数同理也可以使用noexcept)**

#### 源对象必须可析构

**从一个对象移动数据并不会销毁此对象，但有时候在移动操作完成后，源对象会被销毁。**所以在编写移动操作时，**必须确保被移动的后的对象是可以安全析构的。**如之前代码所示，在移动后，我们将被移动的对象的 string 指针置为了空，这时候就可以安全析构了，因为在析构函数中我们已经做了判断，如果 string 指针为空，我们就不进行 free 操作。

#### 合成的移动操作

如果不声明自己的拷贝构造或拷贝赋值运算符，那么编译器会自动为我们合成。其要么被定义为逐个成员拷贝，要么被定义为对象赋值，或者直接定义为删除（也就是 MyString(const MyString&) = delete;）。

但与拷贝操作不同，除非你没有定义自己的拷贝构造、拷贝赋值或者析构函数，不然的话，编译器是不会去合成移动操作的。也就是说，**只有在你自己没有定义任何拷贝控制成员的情况下，编译器才可能会去合成移动操作。**如果一个类没有移动操作，通过正常函数匹配，则会去调用对应的拷贝操作来代替移动操作。

**如果我们用 =default 来要求编译器生成移动操作，那么在编译器不能移动所有成员的情况下，还是会将移动操作定义为删除的函数（=delete）。**

还有一点值得注意：**如果一个类定义了自己的移动操作而不定义拷贝操作，那么拷贝构造和拷贝赋值都将被定义为删除的函数（=delete）。**

#### 移动右值，拷贝左值

如果一个类既有移动构造，也有拷贝构造，编译器就使用普通的函数匹配规则来确定使用哪个构造函数。拿 MyString 举例，拷贝构造可以接受任何可以转换为 MyString 类型的数据。而移动构造只能接受 MyString&&，也就是只能接受右值。**如果一个类没有移动构造，那么如上节所述，会调用拷贝构造，即使使用 std::move() 传一个右值也是一样。**我们将之前 MyString 类的移动构造注释掉，再执行下列程序，看看会发生什么：

```c++
int main(int argc, char* argv[]) {
  //此代码的前提是，MyString的移动拷贝构造函数已被删除
  MyString s1("Hello World");//调用拷贝构造函数
  MyString s2(std::move(s1));//调用拷贝构造函数
  std::cout << std::endl;
  return 0;
}
```

#### 三/五法则

所谓三/五法则，就是指将五个拷贝控制成员（三个基本操作：拷贝构造、拷贝赋值、析构，两个移动操作：移动构造、移动赋值）看作一个整体：一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。比如我们的 MyString 类，必须定义拷贝构造函数、拷贝赋值运算符以及析构函数才能正确工作（因为我们需要分配内存和释放内存，这些活编译器可不会为我们做）。拷贝一个资源会导致额外开销，在这种拷贝非必要的情况下，移动操作就可以避免这种开销。

#### 转发

 最后一个主题：转发。什么是转发？在我们调用函数的时候，会把实参传递给函数，有时候我们传给函数的是左值，有时候给的是右值，有时候还可能给的是 const 类型。在这些情况下，我们要求函数接收参数后，依然能保持这些类型，这时候就需要用转发了。看下面这个例子：

```c++
template <typename F, typename T1, typename T2>
void middle1(F f, T1 t1, T2 t2) {
  f(t1, t2);
}
```

面这个模板函数有三个参数，第一个 f 是一个函数，t1 和 t2 是传给 f 的参数。这个模板函数当然没啥作用，只是为了演示而已。我们可以直接调用 f，也可以通过模板函数 middle1 来调用 f，下面这段代码演示了两者的区别。

```c++
void f(int v1, int& v2) {  // v2 是一个引用
  ++v1;
  ++v2;
}

int main(int argc, char* argv[]) {
  int i = 0;
  f(42, i);
  cout << "After call the f directly: " << i << endl;//i的值为1
  middle1(f, 42, i);
  cout << "Call f through middle1: " << i << endl;//i的值依旧是1
  /*
  原因：
  问题就出在 middle 上，虽然说 f 接收的参数是一个引用，但 middle 的参数却不是。当我们将 i 绑   定到 middle 的参数 t2 上后，传给 f 的是 t2，而 t2 只是一个普通的、非引用的类型 int，而不是   对 i 的引用。所以 i 的值并没有改变。（即v2是t2的别名，而不是上面i的，而导致的问题。）
  */
}
```

#### 保留类型信息

再来看第二个版本的 middle，将 t1 和 t2 都定义为右值引用：

```c++
template <typename F, typename T1, typename T2>
void middle2(F f, T1&& t1, T2&& t2) {
  f(t1, t2);
}

int main(int argc, char* argv[]) {
  int i = 0;
  middle2(f, 42, i);
  cout << "Call f through middle2: " << i << endl;//i的值变为1了
}
```

在 middle2 中，实参的“左值性“得到了保留。这就要归功于 **引用折叠** 了，简单说一下引用折叠：

- `X& &`、`X& &&` 和 `X&& &` 都会折叠成类型 `X&`(这也是上面为啥右值可以在无移动构造函数时，可以触发拷贝构造函数)
- 类型 `X&& &&` 折叠成 `X&&`

**注意：引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。就是说你不能这样直接用：**

```c++
int& i = 1;
int&& j = i; // 很显然错了
```

然而现实是残酷的，这个版本的 middle 只解决了一部分问题，考虑如下函数：

```c++
void g(int &&v1, int& v2) {
  ++v1;
  ++v2;
}
```

其中，i 是右值引用，我们在 main 函数中通过 middle2 调用 g：,将会报错

```c++
int main(int argc, char* argv[]) {
  int i = 0;
  middle2(g, 42, i);//报错的原因：v1是一个右值变量，而所有变量又都是左值，所以g的v1不匹配。
  cout << "Call g through middle2: " << i << endl;
}
```

#### std::forward 登场

那到底该怎么办呢，我们可以使用 forward 这个新标准库来传递 middle2 的参数，它能够保持原始实参的类型，forward 和 move 一起，都定义在 utility 头文件中。move 可以直接调用：`std::move(i)` ，**但 foward 要明确给出模板参数：`std::foward<int>(i)` 才能使用。**forward 会模板参数类型的右值引用，也就是：`int&&` 。**注意，如果我们这样使用：`std::forward<int&>(i)` 返回的就是 `int& &&` ，进而折叠为 `int&` 。**

一般来说，**模板函数中的参数类型为右值引用的时候，就需要搭配 forward 来使用，通过 forward 和引用折叠，就可以完美的保留参数类型了：**

```c++
template <typename F, typename T1, typename T2>
void middle3(F f, T1&& t1, T2&& t2) {
  //保证了
  f(std::forward<T1>(t1), std::forward<T2>(t2));
}

void g(int&& i, int& j) {
  ++i;
  ++j;
}

int main(int argc, char* argv[]) {
  int i = 0;
  middle3(g, 42, i);
  cout << "Call g through middle3: " << i << endl//i的值变为1了
}
```

