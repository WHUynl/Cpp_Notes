#### ● 请你来说一下一个C++源文件从文本到可执行文件经历的过程？

##### 参考回答：

对于C++源文件，从文本到可执行文件一般需要四个过程：

预处理阶段：对源代码文件中文件包含关系（**头文件**）、预编译语句（**宏定义**）**进行分析和替换，生成预编译文件。**

编译阶段：将经过预处理后的预编译文件**转换成特定汇编代码，生成汇编文件**

汇编阶段：将编译阶段生成的汇编文件**转化成机器码，生成可重定位目标文件**

链接阶段：**将多个目标文件及所需要的库连接成最终的可执行目标文件**

#### ● 请你来回答一下include头文件的顺序以及双引号””和尖括号<>的区别？

##### 参考回答：

Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。**那么要在a.cpp文件中引用b.h文件，并且要先引用b.h，后引用a.h**。否则汇报变量类型未声明错误。

双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。

对于使用**双引号**包含的头文件，查找头文件路径的顺序为：

1.当前头文件目录

2.编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）

3.系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

对于使用**尖括号**包含的头文件，查找头文件的路径顺序为：

1.编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）

2.系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

#### 请你说一说C++的内存管理是怎样的？

##### 参考回答：

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552467921124_13956548C4BB199139A2744C39350272)

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。

代码段:包括**只读存储区和文本区**，其中**只读存储区存储字符串常量**，**文本区存储程序的机器代码**。

数据段：存储程序中**已初始化的全局变量和静态变量**

bss 段**：存储未初始化的全局变量和静态变量，以及所有被初始化为0的全局变量和静态变量。**

堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

映射区:存储**动态链接库**以及**调用mmap函数进行的文件映射**

栈：使用栈空间存储**函数的返回地址、参数、局部变量、返回值**

#### ● 请你来说一下什么时候会发生段错误

##### 参考回答：

段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：

1.使用野指针

2.试图修改字符串常量的内容

#### ● 请你来回答一下什么是memory leak，也就是内存泄漏

##### 参考回答：

内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

内存泄漏的分类：

1.堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.

2.**系统资源泄露**（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,**SOCKET**等没有使用相应的函数释放掉，**导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。**

3.**没有将基类的析构函数定义为虚函数。**当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

#### 请你来回答一下new和malloc的区别

##### 参考回答：

1、new分配内存按照**数据类型**进行分配，malloc分配内存**按照指定的大小分配**；

2、new返回的是指定**对象的指针**，而**malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。**

3、new不仅分配一段内存，**而且会调用构造函数**，**malloc不会**。

4、new分配的内存要用delete销毁，malloc要用free来销毁**；delete销毁的时候会调用对象的析构函数，而free则不会。**

5、**new是一个操作符可以重载，malloc是一个库函数**。

6、**malloc分配的内存不够的时候，可以用realloc扩容。**new没用这样操作。

7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。

8、申请数组时： **new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]**，delete[]多次调用析构函数，销毁数组中的每个对象。**而malloc则只能sizeof(int) * n**。

#### 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？

##### 参考回答：

Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，**先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。**当用户申请内存时，**直接从堆区分配一块合适的空闲块。**malloc采用**隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块**；同时malloc采用**显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。**

当进行内存分配时，Malloc会通过**隐式链表遍历所有的空闲块，选择满足要求的块进行分配**；当进行内存合并时，malloc采用**边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。**

Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当**申请内存小于128K时，会使用系统函数brk在堆区中分配**；而当**申请内存大于128K时，会使用系统函数mmap在映射区分配。**

