#### 1.1 nullptr调用成员函数可以吗？为什么？

能。

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

```c++
//给出实例
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn=nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}  
//即breathe(*this)的this指针为空，但是不使用this的话，则不会出问题。
```

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。

#### 2. 说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序

**参考答案**

1. 创建派生类的对象，**基类的构造函数优先被调用**（也优先于派生类里的成员类）；

2. 如果类里面有成员类，**成员类的构造函数优先被调用**；(也优先于该类本身的构造函数）

3. 基类构造函数如果有多个基类，则**构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序（即顺序由 Base:public Derived1,public Derived2 来决定。）**；

4. 成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是**对象在类中被声明的顺序而不是它们出现在成员初始化表中**的顺序；

5. 派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是**把值传递给适当的基类构造函数**,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）

6. 综上可以得出，初始化顺序：

   **父类构造函数–>成员类对象构造函数–>自身构造函数**

   其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。

   析构顺序和构造顺序相反。

#### 3. 简述下向上转型和向下转型

1. 子类转换为父类：向上转型，使用**dynamic_cast(expression)**，这种转换相对来说比较安全不会有数据的丢失；
2. 父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。

#### 4. 简述下深拷贝和浅拷贝，如何实现深拷贝

1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。
2. 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。
3. 深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：

```c++
STRING( const STRING& s )
{
    //_str = s._str;
    _str = new char[strlen(s._str) + 1];
    strcpy_s( _str, strlen(s._str) + 1, s._str );
}
STRING& operator=(const STRING& s)
{
    if (this != &s)
    {
        //this->_str = s._str;
        delete[] _str;
        this->_str = new char[strlen(s._str) + 1];
        strcpy_s(this->_str, strlen(s._str) + 1, s._str);
    }
    return *this;
}
```

####  5. 请你回答一下 C++ 类内可以定义引用数据成员吗？

c++类内可以定义引用成员变量，但要遵循以下三个规则：

**原则就是：引用必须声明时就定义**

1. **不能用默认构造函数初始化**，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. **构造函数的形参也必须是引用类型**。
3. 不能在构造函数里初始化，**必须在初始化列表中进行初始化**。

#### 6.说说什么是虚继承，解决什么问题，如何实现？

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题

```c++
//不使用虚继承的弊端。
#include<iostream>
using namespace std;
class A{
public:
    int _a;
};
class B :virtual public A
{
public:
    int _b;
};
class C :virtual public A
{
public:
    int _c;
};
class D :public B, public C
{
public:
    int _d;
};
//菱形继承和菱形虚继承的对象模型
int main()
{
    D d;
    d.B::_a = 1;
    d.C::_a = 2;
    d._b = 3;
    d._c = 4;
    d._d = 5;
    cout << sizeof(D) << endl;
    return 0;
}
```



#### 7. 请问拷贝构造函数的参数是什么传递方式，为什么

**参考回答**

1. 拷贝构造函数的参数必须使用**引用传递**

2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而**传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。**因此拷贝构造函数的参数必须是一个引用。

   ```c++
   class CClass;
   CClass(const CClass c_class);//假如是传值作为拷贝构造函数的参数
   //则必然会执行隐式的代码
   const CClass c_class(other_class)//好家伙，又是拷贝构造函数
   const CClass c_c_class(other_class)//继续下去了
   ```

   需要澄清的是，**传指针其实也是传值**，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。

#### 8. 简述一下拷贝赋值和移动赋值？

**参考回答**

1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。

2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于

   1）拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；

   2）拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是**生成一个指针指向源对象或变量的地址，接管源对象的内存**，相对于大量数据的拷贝节省时间和内存空间。(这也是为什么要将源对象的指针全部置为nullptr)

#### 9. C++ 中哪些函数不能被声明为虚函数？

**参考回答**

常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。

1. 为什么C++不支持普通函数为虚函数？

   普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。

2. 为什么C++不支持构造函数为虚函数？

   这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（**基类尚未构造完成，又怎么能调用到派生类的构造函数呢？**）（这不就是典型的悖论）

   构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数

3. 为什么C++不支持内联成员函数为虚函数？

   其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（**再说了，*inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数***）

   内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数

4. 为什么C++不支持静态成员函数为虚函数？

   这也很简单1.3.34 C++ 中哪些函数不能被声明为虚函数？

   **参考回答**

   常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。

   1. 为什么C++不支持普通函数为虚函数？

      普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。

   2. 为什么C++不支持构造函数为虚函数？

      这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）

      构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数

   3. 为什么C++不支持内联成员函数为虚函数？

      其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，*inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数*）

      内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数

   4. 为什么C++不支持静态成员函数为虚函数？

      这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。

      静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别

   5. 为什么C++不支持友元函数为虚函数？

      因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

   静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别

5. 为什么C++不支持友元函数为虚函数？

   因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

#### 10. 虚函数表里存放的内容是什么时候写进去的？

**参考回答**

1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：**虚表在构造函数之前写入**
2. 除了在构造函数之前写入之外，我们还需要考虑到**虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表**，为实现动多态提供支持。

#### 11.仿函数了解吗？有什么作用

**参考回答**

1. 仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，举个例子：

```c++
class Func{
     public:
         void operator() (const string& str) const {
             cout<<str<<endl;
         }
 };
 Func myFunc;
 myFunc("helloworld!");
//helloworld!
```

